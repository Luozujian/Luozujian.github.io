<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode专题训练</title>
    <url>/2022/10/12/leetcode%E4%B8%93%E9%A2%98%E8%AE%AD%E7%BB%83%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">目标</th>
<th>目标1: Leetcode 500题 (hard 200, middle 200,easy 100) 目标二: 20个知识点</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>收益</strong></td>
<td><strong>后续找工作不在需要花很长时间刷算法题</strong></td>
<td></td>
</tr>
<tr>
<td align="left"><strong>时间安排</strong></td>
<td><strong>工作日 7:00-8.30 22:00-24:00(3.5h) 周末 8:00-11:30 14:00-17:00(6.5h) 一周30h</strong></td>
<td></td>
</tr>
<tr>
<td align="left"><strong>时间周期</strong></td>
<td><strong>2022&#x2F;10&#x2F;12-2023&#x2F;03&#x2F;01</strong></td>
<td></td>
</tr>
<tr>
<td align="left"><strong>刷题方法</strong></td>
<td><strong>五毒神掌</strong> <strong>1-1-5-30-快要面试了复习一遍 主动式反馈和被动式反馈</strong></td>
<td></td>
</tr>
</tbody></table>
<h3 id="刷题方法"><a href="#刷题方法" class="headerlink" title="刷题方法"></a>刷题方法</h3><p>刷多遍是为了熟练，精通一个领域分为三步，Chunk it up 切碎知识点，Deliberate Practicing刻意练习，Feedback(主动式反馈，被动式反馈)</p>
<p><strong>第一周</strong>: <strong>线段树</strong></p>
<p>线段树专题，训练内容单点更新，区间更新，lazy标记，动态开点</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>知识点: 动态开点，单点更新，区间更新， lazy标记</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>知识点</strong></td>
<td>单点更新，区间查询，动态开点</td>
<td></td>
</tr>
<tr>
<td><strong>题目</strong></td>
<td><a href="https://leetcode.cn/problems/range-sum-query-mutable/">leetcode307</a> <a href="https://leetcode.cn/problems/additive-number/">leetcode306</a></td>
<td></td>
</tr>
<tr>
<td><strong>复盘</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>时间</strong></td>
<td><strong>2022&#x2F;10&#x2F;12~2022&#x2F;10&#x2F;16</strong></td>
<td></td>
</tr>
</tbody></table>
<p><strong>复盘，思考与提升：</strong></p>
<p><strong>成为某个领域的专家，切碎知识点(领域的技能数) + 刻意练习 + 反馈(主动反馈和被动反馈)<strong>；</strong>五毒神掌</strong>，同一个题刷多遍，提升熟练程度；刷题不能只想一种方法，应该思考<strong>所有的可能解</strong>，然后分析空间复杂度和时间复杂度；本周是算法训练的起始，不用高度紧张的去刷题，放松一点，本周刷题数量2题，博客文章一篇，距离20题的目标差距很远，刚起步也很正常，博客的质量以及对线段树的理解值得点赞，本周很不错，下周继续加油！:+1:</p>
<p><strong>第二周</strong>： <strong>线段树</strong>，<strong>树状数组</strong></p>
<p>上周线段树刷了两题，本周继续，目标18题，应该尽量涉及lazy标记，区间更新，线段树对最长上升子序列的优化等等</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>知识点: 动态开点，单点更新，区间更新， lazy标记</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>知识点</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>题目</strong></td>
<td><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">leetcode315</a> <a href="https://leetcode.cn/problems/count-of-range-sum/">leetcode327</a> <a href="https://leetcode.cn/problems/my-calendar-ii/">leetcode731</a> <a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">leetcode2407</a></td>
<td></td>
</tr>
<tr>
<td><strong>复盘</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>时间</strong></td>
<td><strong>2022&#x2F;10&#x2F;17~2022&#x2F;10&#x2F;24</strong></td>
<td></td>
</tr>
</tbody></table>
<p><strong>复盘，思考与提升：</strong></p>
<p>本周在工作中负责推进两个项目，前3天误会leader的意思了，有一个我主负责的项目没有推进，在leader的提醒下才继续推进的，<strong>每时每刻对自己主要负责的事情要有一个清晰的认识</strong>；浪费了太多时间，没想清楚自己应该做什么，应该怎么做，<strong>想清楚自己应该做什么，怎么做之后再去做，这样效率会更高，更好</strong>；<strong>对人的话，无论如何一定要尊重人家，无论人是非，也无需太在意别人对我的看法</strong>；对于刷题，本周就只有周一和周二晚上刷题了，<strong>比三天打鱼两天筛网还过分</strong>，还得继续加油；时间安排上面，目前是做<strong>地铁的时间</strong>用来提升之前准备的面经，晚上的<strong>学习时间有所欠缺</strong>，学习到晚上11:50直接休息; 值得表扬的是减肥，坚持一周4天晚上均没有吃晚餐，值得表扬，可以做的更好。</p>
<p>本周的产出: <strong>4题</strong> + <strong>一篇</strong>树状数组文章 + <strong>按照原定计划复习</strong>，总体上来说还有很大的优化空间</p>
<p><strong>第三周: 滑动窗口</strong></p>
<p>本周的训练重点滑动窗口算法</p>
<p><strong>第四周</strong>: <strong>dfs</strong>，<strong>bfs</strong></p>
<p>第五周: </p>
<p>参考资料:</p>
<p><a href="https://github.com/ninechapter-algorithm/leetcode-linghu-templete/blob/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.md">https://github.com/ninechapter-algorithm/leetcode-linghu-templete/blob/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.md</a>  线段树题目总结</p>
]]></content>
      <categories>
        <category>专项计划</category>
      </categories>
      <tags>
        <tag>排期</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树入门</title>
    <url>/2022/10/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、什么是线段树"><a href="#一、什么是线段树" class="headerlink" title="一、什么是线段树"></a>一、什么是线段树</h2><p>线段树是一颗平衡二叉树，其每个节点存储的都是一段区间，常用于解决区间问题(大区间问题的解可以转化成几个小区间问题的解)，比如区间和，区间乘积，区间最大最小值以及gcd等等。</p>
<p><img src="https://img-blog.csdnimg.cn/20210520211956632.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MjU4MTM5,size_16,color_FFFFFF,t_70#pic_center" alt="线段树"></p>
<h2 id="二、线段树的基本操作"><a href="#二、线段树的基本操作" class="headerlink" title="二、线段树的基本操作"></a>二、线段树的基本操作</h2><h3 id="2-1、为什么线段树建树需要开4倍的空间"><a href="#2-1、为什么线段树建树需要开4倍的空间" class="headerlink" title="2.1、为什么线段树建树需要开4倍的空间"></a>2.1、为什么线段树建树需要开4倍的空间</h3><p>线段树不一定是一颗满二叉树也不一定是一颗完全二叉树，当区间的元素个数N满足$2^k&#x3D;N$的时候，其是一颗满二叉树，满二叉树的前k层的节点数量为$2^{k+1}-1$，即总共需要2N-1个节点，当$2^k\neq N$,其构不成一颗满二叉树，假设$N&#x3D;2^k+1$，这样需要新开辟一层，最差需要新增$2^{k+1}$个节点，需要新增很多虚节点不存储任何东西，所以总共需要4N个节点</p>
<p><img src="https://img-blog.csdnimg.cn/20200207092700688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21td3cxOTk0,size_16,color_FFFFFF,t_70" alt="线段树"></p>
<h3 id="2-2、时间复杂度分析"><a href="#2-2、时间复杂度分析" class="headerlink" title="2.2、时间复杂度分析"></a>2.2、时间复杂度分析</h3><h4 id="2-2-1、建树的时间复杂度"><a href="#2-2-1、建树的时间复杂度" class="headerlink" title="2.2.1、建树的时间复杂度"></a>2.2.1、建树的时间复杂度</h4><p>建树的时候，最多操作4N个节点，所以时间复杂度是o(N)</p>
<h4 id="2-2-1、单点更新的时间复杂度"><a href="#2-2-1、单点更新的时间复杂度" class="headerlink" title="2.2.1、单点更新的时间复杂度"></a>2.2.1、单点更新的时间复杂度</h4><p>树的深度为log(N)，查找某一个元素的时候，像一颗二叉搜索树一样从上往下搜索，最多搜索log(N)个节点，找到之后修改，然后再由下往上维护结果，也是最多操作log(N)个节点。所以单点更新的时间复杂度也是log(N)</p>
<h4 id="2-2-2、区间查询的时间复杂度"><a href="#2-2-2、区间查询的时间复杂度" class="headerlink" title="2.2.2、区间查询的时间复杂度"></a>2.2.2、区间查询的时间复杂度</h4><p>当一个节点存储的区间被完全包含在待查询区间[L,R]中，则该节点没称作完全节点，否则称作部分节点。由于区间的连续性可以得知，每层最多有两个完全节点，两个部分节点。所以最多访问4*log(N)个节点，时间复杂度o(logN)	</p>
<h4 id="2-2-3、区间更新的时间复杂度"><a href="#2-2-3、区间更新的时间复杂度" class="headerlink" title="2.2.3、区间更新的时间复杂度"></a>2.2.3、区间更新的时间复杂度</h4><p>在不使用lazy标记的情况下，对于区间中的每一个点都需要进行一次单点更新，时间复杂度o(mlogn)，在使用lazy标记后，相当于是进行区间更新，最多只会更新4*logn个节点，所以时间复杂度为o(logn)</p>
<h4 id="2-2-3、动态开点空间复杂度"><a href="#2-2-3、动态开点空间复杂度" class="headerlink" title="2.2.3、动态开点空间复杂度"></a>2.2.3、动态开点空间复杂度</h4><p>单次区间查询的时间复杂度是o(logn)，q次查询的时间复杂度就是o(qlogn)，空间复杂度和时间复杂度一致o(qlogn)</p>
<h3 id="2-3、代码模板"><a href="#2-3、代码模板" class="headerlink" title="2.3、代码模板"></a>2.3、代码模板</h3><h4 id="2-3-1、传统线段树"><a href="#2-3-1、传统线段树" class="headerlink" title="2.3.1、传统线段树"></a>2.3.1、传统线段树</h4><p>128M大概能开8e6的空间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int <span class="variable constant_">MAXN</span> = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> int <span class="variable constant_">INF</span> = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    int lazy; <span class="comment">//lazy标签</span></span><br><span class="line">    int data; <span class="comment">//区间最大值</span></span><br><span class="line">&#125;st[<span class="variable constant_">MAXN</span> &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储原始数据</span></span><br><span class="line">int a[<span class="variable constant_">MAXN</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//lazy标签下移</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushDown</span>(<span class="params">int p</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (st[p].<span class="property">lazy</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        st[p &lt;&lt; <span class="number">1</span>].<span class="property">lazy</span> += st[p].<span class="property">lazy</span>;</span><br><span class="line">        st[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].<span class="property">lazy</span> += st[p].<span class="property">lazy</span>;</span><br><span class="line">        st[p &lt;&lt; <span class="number">1</span>].<span class="property">data</span> += st[p].<span class="property">lazy</span>;</span><br><span class="line">        st[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].<span class="property">data</span> += st[p].<span class="property">lazy</span>;</span><br><span class="line">        <span class="comment">//切记把lazy标签复原</span></span><br><span class="line">        st[p].<span class="property">lazy</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果上推</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushUp</span>(<span class="params">int p</span>) &#123;</span><br><span class="line">    st[p].<span class="property">data</span> = <span class="title function_">min</span>(st[p &lt;&lt; <span class="number">1</span>].<span class="property">data</span>, st[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不带lazy标记的区间查询</span></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int l, int r, int p</span>) &#123;</span><br><span class="line">    <span class="comment">//完全节点</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= st[p].<span class="property">l</span> &amp;&amp; r &lt;= st[p].<span class="property">r</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> st[p].<span class="property">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (st[p].<span class="property">l</span> + st[p].<span class="property">r</span>) &lt;&lt; <span class="number">1</span>, val = -<span class="variable constant_">INF</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) val = <span class="title function_">min</span>(val, <span class="title function_">query</span>(l, r, p &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) val = <span class="title function_">min</span>(val, <span class="title function_">query</span>(l, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带lazy标签的区间查询</span></span><br><span class="line">int <span class="title function_">query2</span>(<span class="params">int l, int r, int p</span>) &#123;</span><br><span class="line">    <span class="comment">//完全节点</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= st[p].<span class="property">l</span> &amp;&amp; r &lt;= st[p].<span class="property">r</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> st[p].<span class="property">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int mid = (st[p].<span class="property">l</span> + st[p].<span class="property">r</span>) &gt;&gt; <span class="number">1</span>, val = -<span class="variable constant_">INF</span>;</span><br><span class="line">    <span class="comment">//在查询子节点之前，结果下推</span></span><br><span class="line">    <span class="title function_">pushDown</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) val = <span class="title function_">min</span>(val, <span class="title function_">query</span>(l, r, p &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) val = <span class="title function_">min</span>(val, <span class="title function_">query</span>(l, r, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点修改</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int x, int val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (st[p].<span class="property">l</span> == x &amp;&amp; st[p].<span class="property">r</span> == x) &#123;</span><br><span class="line">        st[p].<span class="property">data</span> = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (st[p].<span class="property">l</span> + st[p].<span class="property">r</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="title function_">update</span>(p &lt;&lt; <span class="number">1</span>, x, val);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; mid) <span class="title function_">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, val);</span><br><span class="line">    <span class="title function_">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间更新带lazy标签</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update2</span>(<span class="params">int p, int l, int r, int x</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是个完全节点</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= st[p].<span class="property">l</span> &amp;&amp; st[p].<span class="property">r</span> &lt;= r) &#123;</span><br><span class="line">        st[p].<span class="property">data</span> += x;</span><br><span class="line">        st[p].<span class="property">lazy</span> += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (st[p].<span class="property">l</span> + st[p].<span class="property">r</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//修改下层节点之前先把lazy标签下移</span></span><br><span class="line">    <span class="title function_">pushDown</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="title function_">update2</span>(p &lt;&lt; <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="title function_">update2</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);</span><br><span class="line">    <span class="title function_">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int l, int r</span>) &#123;</span><br><span class="line">    st[p].<span class="property">l</span> = l, st[p].<span class="property">r</span> = r, st[p].<span class="property">lazy</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        st[p].<span class="property">data</span> = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="title function_">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="title function_">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2、动态开点"><a href="#2-3-2、动态开点" class="headerlink" title="2.3.2、动态开点"></a>2.3.2、动态开点</h4><p>动态开点模板，不使用结构体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int <span class="variable constant_">MAXN</span> = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> int <span class="variable constant_">INF</span> = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态开点的数量</span></span><br><span class="line">int cnt = <span class="number">0</span>, root = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lazy懒惰标签，data存储区间最小值，lson记录节点的左儿子的编号，rson记录节点的右儿子编号</span></span><br><span class="line">int lazy[<span class="variable constant_">MAXN</span> &lt;&lt; <span class="number">2</span>], data[<span class="variable constant_">MAXN</span> &lt;&lt; <span class="number">2</span>], lson[<span class="variable constant_">MAXN</span> &lt;&lt; <span class="number">2</span>], rson[<span class="variable constant_">MAXN</span> &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储原始数据</span></span><br><span class="line">int a[<span class="variable constant_">MAXN</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果往上传递</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushUp</span>(<span class="params">int p</span>) &#123;</span><br><span class="line">    data[p] = <span class="title function_">min</span>(data[lson[p]], data[rson[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lazy标记下推</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushDown</span>(<span class="params">int p</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lson[p]) lson[p] = ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (!rson[p]) rson[p] = ++cnt;</span><br><span class="line">        data[lson[p]] += lazy[p];</span><br><span class="line">        data[rson[p]] += lazy[p];</span><br><span class="line">        lazy[lson[p]] += lazy[p];</span><br><span class="line">        lazy[rson[p]] += lazy[p];</span><br><span class="line">        lazy[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//区间查询</span></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int &amp;p, int l, int r, int ql, int qr</span>) &#123;</span><br><span class="line">    <span class="comment">//如果这个节点的编号 = 0，则代表还没有开点</span></span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> data[p];</span><br><span class="line">    int mid = (l + r) &gt;&gt; <span class="number">1</span>, val = -<span class="variable constant_">INF</span>;</span><br><span class="line">    <span class="title function_">pushDown</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) val = <span class="title function_">min</span>(val, <span class="title function_">query</span>(lson[p], l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) val = <span class="title function_">min</span>(val, <span class="title function_">query</span>(rson[p], mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//区间更新</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int &amp;p, int l, int r, int ql, int qr, int val</span>) &#123;</span><br><span class="line">    <span class="comment">//如果这个节点 = 0，则代表还没有开点</span></span><br><span class="line">    <span class="keyword">if</span> (!p) p = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        lazy[p] += val;</span><br><span class="line">        data[p] += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushDown</span>(p);</span><br><span class="line">    int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="title function_">update</span>(lson[p], l, mid, ql, qr, val);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) <span class="title function_">update</span>(rson[p], mid + <span class="number">1</span>, r, ql, qr, val);</span><br><span class="line">    <span class="title function_">pushUp</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>参考资料:</p>
<p><a href="https://blog.csdn.net/qq_46258139/article/details/117091960">题目汇总</a></p>
<p><a href="https://blog.csdn.net/qq_46258139/article/details/117091960">线段树4n存储空间</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/152285749">满二叉树的定义</a></p>
<p><a href="https://www.shuzhiduo.com/A/MAzAvLvMJ9/">区间查询的时间复杂度证明</a></p>
<p><a href="https://blog.csdn.net/qq_52678569/article/details/124595544">线段树动态开点</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组入门</title>
    <url>/2022/10/18/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="一、什么是树状数组-binary-index-tree-BIT"><a href="#一、什么是树状数组-binary-index-tree-BIT" class="headerlink" title="一、什么是树状数组(binary index tree, BIT)"></a>一、什么是树状数组(binary index tree, BIT)</h3><p>树状数组是用来解决单点更新以及区间求和问题的一种数据结构，其定义$lowbit(x)$为$x$对应的二进制右边第一个1即其后面的0组成的一个数。数组$C$，每个元素$Ci$维护区间$(Ci - lowbit(Ci), Ci]$的累加和。</p>
<p>$$<br>lowbit(110110_2) &#x3D; 10_2<br>$$</p>
<h3 id="二、如何求前N项和"><a href="#二、如何求前N项和" class="headerlink" title="二、如何求前N项和"></a>二、如何求前N项和</h3><p>求前$N$项和可以分解成几个小区间进行求和，那么如何分呢？我们可以利用二进制来进行划分，比如求前$13(1101_2)$项的和，可以按照二进制划分成区间$(1100,1101]，(1000,1100],(0000, 1000]$这三个区间，规律就是每次减去$lowbit(x)$即可，这样最多减去$log_2^n$个lowbit就会等于0了，所以前N项和的时间复杂度是$O(logN)$</p>
<h3 id="三、如何进行单点更新"><a href="#三、如何进行单点更新" class="headerlink" title="三、如何进行单点更新"></a>三、如何进行单点更新</h3><p>当更新某一个点$X$的时候，只需要更新哪些包含点$X$的区间所对应的点即可，那么哪些点维护的区间包含点$X$呢？可以观察如何这个图，可以发现从点$X$开始，不断加$lowbit()$等于的点所维护的区间都包含点$X$，而其他点所维护的区间均不包含$X$。可见最多也只需要更新$log_2^n$个区间，对于如何证明包含点$X$的区间只有$X$不断加上$lowbit()$等于的点维护，暂时不考虑</p>
<p><img src="https://pic3.zhimg.com/v2-fbaeb49fdbad31a211fe37f068ca8bb0_1440w.jpg?source=172ae18b"></p>
<h3 id="四、代码模板"><a href="#四、代码模板" class="headerlink" title="四、代码模板"></a>四、代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单点更新</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt; MAXN; i += <span class="built_in">lowbit</span>(i)) a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求前n项和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) val += a[i];</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间求和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p>参考资料:</p>
<p>1.<a href="https://zhuanlan.zhihu.com/p/93795692">https://zhuanlan.zhihu.com/p/93795692</a> 数组数组入门</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2022/10/23/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
</search>
